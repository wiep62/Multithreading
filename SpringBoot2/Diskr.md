34. Работа с базой данных. Spring Data JPA (переводчик между кодом JAVA и БД) вместо изучения нового СКл он переводит СКЛ на нужный язык БД
    JPA — Java Persistence API, интерфейс Java EE,
    разработанный для взаимодействия Java-приложений
    с реляционными базами данных.

Object-Relational Mapping

JPA по сути является ORM-системой (Object-Relational
Mapping), которая обеспечивает отображение объектов
Java на данные в реляционных базах, и наоборот.
Снижает количество SQL-кода в приложении.
Spring Data JPA (предоставляет специальный ENTYTY менеджер, который управляет сущностями и их жизненным циклом (как СПРИНГ контейнер, который управляет бинами)).
Аннотации JPA
Обозначают сущности и их отношения.
@Entity
@Table
@OneToMany
@ManyToOne

Репозитории
Специальные интерфейсы, которые предоставляют
удобные методы для выполнения операций чтения
и записи данных в базу.
Вы можете создать свой собственный репозиторий
или использовать стандартные CrudRepository
или JpaRepository из Spring Data JPA.

35. Подключение к базе данных
    PostgreSQL — это свободно распространяемая объектнореляционная система управления базами данных (СУБД)
    с открытым исходным кодом, написанным на языке C.

    Преимущества    PostgreSQL :

    * Является свободным и открытым программным
      обеспечением. Вы можете использовать его
      бесплатно и даже вносить вклад в его развитие
    * Придерживается стандартов SQL, что облегчает
      перенос приложений между разными СУБД.
    * Вы можете легко настроить PostgreSQL под свои
      потребности, добавляя расширения и настраивая
      параметры
    * Предоставляет возможность работать с JSONданными (геопространственными, не реалеционными бд)

36. доб. зависимость:
    <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
37. Добавим докр контейнер:
* docker run -p 5432:5432 --name postgresql -e POSTGRES_PASSWORD=skillbox -e POSTGRES_DB=skillbox -d postgres:14
*   docker ps
    CONTAINER ID   IMAGE         COMMAND                  CREATED          STATUS          PORTS                    NAMES
    9e73f9365e61   postgres:14   "docker-entrypoint.s…"   18 seconds ago   Up 17 seconds   0.0.0.0:5432->5432/tcp   postgresql
* Подкл. приложения к базе:
- в конф-ии приложения АППЛИКЕЙШН добавим параметры:
  spring:
  datasource:
  url: jdbc:postgresql://localhost:5432/skillbox
  username: skillbox
  password: skillbox
  driver-class-name: org.postgresql.Driver
- SPRING DATE JPI не содержит драйверы для каждой отдельной БД , поэтому его нужно добавить с помощью зависимостей :
  <dependency>
  <groupId>org.postgresql</groupId>
  <artifactId>postgresql</artifactId>
  </dependency>

38. Сущности (КЛЮЧЕВОЙ МОМЕНТ JAVA API И JAVA SPRING DATA JPA)   и аннотация @Entity
    
    @Entity позволяет определять классы-сущности,
    соответствующие таблицам в базе данных.
    import jakarta.persistence.Entity;
    import jakarta.persistence.Table;

@Entity
@Table(name = "comment") //позволяет в явном виде указывать название таблицы, которй будет связан класс коммент

создадим свойства, которые будут у нашей сущности:
public class Comment {
//идентификатор коментария
private Integer id;
//текст коментария
private String text;
//автор коментария
private String author;

}
ОТМЕТИМ ЭТИ ПОЛЯ СПЕЦИАЛЬНЫМИ АННОТАЦИЯМИ:
-добавить 1-ый ключ.
- у каждого поля установить аннотацию колумн (внутри указать имя соотв-ую полу в БД)
  ***КАЖДОЕ СВОЙСТВО ОБЪЕКТА КЛАССА КОММЕНТ БУДЕТ РАВНО ИМЕНАМ ПОЛЯ В БД
  СОЗДАДИМ ДАТУ И ВРЕМЯ СОЗДАНИЯ КОМЕНТАРИЯ:
  @Column(name = "creation_time")
  private LocalDateTime time; --можно разные имена задавать

  @CreationTimestamp //используется для автомат-ой установки времени создания записи в базе
  @Column(name = "creation_time")
  private LocalDateTime time;
  поле creation_time будет автоматически заполнено врменем при создании комментария
  -добавим @GeneratedValue(strategy = GenerationType.IDENTITY) используется для указания каким образом ,
  значение 1-ых ключей (значение в поле id) нашей таблицы. Будут генерироваться
  при вставке новых записей в БД
  @Id //1-й ключ для таблицы "коммент"
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  @Column(name = "id")
  private Integer id;

**** СУЩЕСТВУЕТ НЕСКОЛЬКО СТРАТЕГИЙ ГЕНЕРАЦИИ ПЕРВИЧНОГО КЛЮЧА:
Виды стратегий
AUTO (по умолчанию) (позволяет поставщику jpa, выбрать наиболее подходящий способ генерации значений. (в завис-ти от БД м.б. генерация с помощью автоинкрементных столбцов айдентити в мускл))
IDENTITY - генер-ия значений с использованием автоинкрементных столбцов в БД если они поддерживаются (исп-ся с БД муСКЛ и пострееСКЛ)
SEQUENCE - ген-ия знач-ий с использ-ием послед-ти БД (подходит для БД в которых исп-ся последовательности - ОРАКЛ)
TABLE - генер-ия значений с использ-ием специальной таблицы в БД, которая хранит инф-ию о текущем значении, она М эфективнеа чем ИДЕНТИТИ или СЕКВАЛС  

* будем использовать стратегии IDENTITY и передадим обязонность по созданию 1-ых ключей на сторону БД:
СОЗДАДИМ ТАБЛИЦУ В БД, воспользуемся системой ХИБЕРНАТЕ 
и добавим в файл конфм=игурации специальную настройку в АПЛИКЕЙШН ЯМЛ
по которой ХИБЕРНАТЕ будет определять, что нам нужно при запуске приложения
соотв-ие нашим ЕНТИТИ классам:
  jpa:
  show-sql: tru делает так чтобы хибернейт логировал все СКЛ запросы которые он будет логировать в БД
и выводить их в консоль.
  hibernate.ddl-auto: create будет говорить хибернату о том что он должен создавать таблицы в базе


Репозиторий
Сущности и репозитории
Создаётся при помощи интерфейса.
JPA Repository — это интерфейс, предоставляемый Spring
Data JPA, который упрощает взаимодействие с базой
данных в Java-приложениях, использующих Java Persistence
API. Он предоставляет абстракцию над уровнем доступа
к данным и позволяет разработчикам выполнять операции
CRUD (Create, Read, Update, Delete) над сущностями
базы данных с минимальными усилиями.

Плюсы Repository
Декларативное определение методов (Spring Data JPA автоматически создаст необх-ые СКл запросы на основе названий методов и их параметров)
Поддержка стандартных операций (репоз-ии JPA пред-ют стандартные методы для вып-ия КРУД операций) например: метод СЕЙФ - для сохр-ия сущности , ФАЙНБУАЙДИ для поиска по идентификатору, ДЕЛИТЕ для удаления и т.д.
Генерация SQL-запросов (Spring Data JPA создает СКЛ запросы основанные на методах репозитория)
Поддержка именованных запросов (репозитории также поддерживают именованые запросы, которые можно определять с использованием аннотации НАЙМЕДКВЕРИ - обесп. более гибкий и настраиваемый доступ к данным)
Поддержка постраничной навигации и сортировки (репозиторий позволяет легко реализовывать такую пагинацию и сортировку результатов запросов)
Автоматическая генерация репозитория (Spring Data JPA позволяет создавать репозитории на основе интерфейсов без необходимости их реализации)

39. СОЗДАДИМ репозиторий для сущности КОММЕНТ (repositories):
Достаточно создать интерфейс и унаследовать его от интерфейса  JPA репозиторий и задать типизацию:
    public interface CommentRepository extends JpaRepository<Comment, Integer> {
    }
    Comment - класс сущности с которой мы раьотаем и Integer (тип первичного ключа сущности)
и добавим анностацию репозитория
    @Repository - явл. псевдонимом аннотации КОМПОНЕНТ, он она обесп-ет обраб-ку искл-ий от БД, преобразуя их в исключение спринг ДЭТА АКСЦЕСС ЕКСЕПШН
Это упр-ет обр-ку ошибок при работе с БД.
40. поменяем CommentCRUDService чтобы он работал не с ТРИМЕПОМ а с БД:
добавим поле в котором будет объект нашего репозитория
    private final CommentRepository repository;
вместо создания его в конструкторе добавим аннотацию из ЛОМБОК:
    @RequiredArgsConstructor она позволит создать конструктор в классе, но только длоя полей с модификатором final
    @Slf4j
заменим  System.out.println() на log.info
добавим 2 статических метода , которые позволят преобр-ть КОМЕНТ ЕНТИТИ в объекты класса КОММЕНТ ДТО и наоборот
    public static CommentDto mapToDto(Comment comment) { }

    public static CommentDto mapToDto(Comment comment) {
    //чтобы КОММЕНТгетИД заработал, нужно добавить геттеры и сеттеры в СОММЕНТ.ДЖАВА
    CommentDto commentDto = new CommentDto(); //для того чтобы можно было использовать конструктор без аргументов, нужно указать в АННОТАЦИИ КомментДТО без аргументов
    commentDto.setId(comment.getId());
    commentDto.setText(comment.getText());
    commentDto.setAuthor(comment.getAuthor());
    return commentDto;
    }
***
во втором случае делаем наоборот:
//обратная операция:
public static Comment mapToEntity(CommentDto commentDto) {
Comment comment = new Comment();
comment.setId(commentDto.getId());
comment.setText(commentDto.getText());
comment.setAuthor(commentDto.getAuthor());
return comment;
}
41. Используем наш репозиторий:
чтобы получить по идентификатору комментарий из соотв-ей БД нам нужно выполнить метод repository.findById(id); -этот метод возвр-ет опшинал, соотв-но нам тут нужен КОММЕНТ ДТО и выдаем ЭКСЕПШН если соотв-ий комментарий не найден,
и преобразуем его в ДТО при помощи только что созд-го статического метода:
    Мы так обращаемся к БД и получаем элемент по его ИД:
    @Override
    public CommentDto getById(Integer id) {
    log.info("Getting comment by id: " + id);
    Comment comment = repository.findById(id).orElseThrow();
    return mapToDto(comment);
    }
42. Получим все комментарии из БД:
берем репозиторий и вызываем метод ФАЙНД ОЛЛ.
    findAll возвращает список объектов класса Comment, а нам нужна коллекция объектов класса КОММЕНТДТО,
воспользуемся стримами и обработаем каждый элемент этой коллекции при помощи статического метода КОММЕНТКРУДсервисе МАПтоДТО и преобразуем в список:
    @Override
    public Collection<CommentDto> getAll() {
    log.info("Getting all comments");
    return repository.findAll()
    .stream()
    .map(CommentCRUDService::mapToDto)
    .toList();
    }
43. есть метод create который создает сущность , по хорошему нам нужно получить сущность 
преобразовав соментДТО в объект класса КОММЕНТ , затем берем репозиторий и вызываем метод СЕЙФ,
передавая туда объекты этого класса:
    @Override
    public void create(CommentDto item) {
    log.info("Creating comment: " + item);
    Comment comment = mapToEntity(item);
    repository.save(comment);
    }
44.  в обновлении ИД можно не передавать, т.к. внутри ИД уже содержится , а дальше все как у КРЕАТЕ:
     @Override - ругается что этот метод не переопределяет метод класса родителя , в классе родителя уберем параметр ИД (в public interface CRUDService<T> { в     void update(Integer id, T item);
     нужно убрать параметр ИД) 
     public void update(CommentDto item) {
     log.info("Updating comment: ");
     Comment comment = mapToEntity(item);
     repository.save(comment);
     }
45. в public class CommentController {
тоже убрать ИД в :
    @PutMapping("/{id}")
    public void updateComment(@PathVariable Integer id, @RequestBody CommentDto commentDto) {
    commentDto.setId(id); //в коммент ДТО установим новый идентификатор
    commentService.update(commentDto);
    }
46. УДАЛЕНИЕ:
объект класса делите должен получать объект класса коммент:
    @Override
    public void delete(Integer id) {
    log.info("Deleting comment: " + id);
    repository.deleteById(id);
    }
47. комментарии не сохр. потому что в конфигурации базы написано КРЕАТЕ (при каждом перезапуске нашего приложения БД будет пересоздаваться ) поэтому меняем на ВАЛИДЕТ:
    hibernate.ddl-auto: create  ->   hibernate.ddl-auto: validate
48. СВЯЗИ МЕЖДУ СУЩНОСТЯМИ: (между таблицами : 1 к 1, 1 к М, М к М)
СПРИНГ ДАТА JPA позволяет создавать любые типы связей
**** Создадим сущность АВТОР и настроим связь 1 ко многим по отношению к коментариям.
- до этого в  качестве автора использовали СТРОКУ (это не удобно т.к. у авторов могут быть свои свойства)
Удобнее хранить автора в отдельной таблице БД, создадим класс автор.
- привяжем авторов к коментариям, у 1 автора может быть несколько комментариев (связь 1 к М), у авторов нужно добавить переменную лист, которрая будет содержать в себе список коментарниев данного автора
  @OneToMany(mappedBy = "author", cascade = CascadeType.ALL)  cascade = CascadeType.ALL - этот параметр указывает , что все коментарии нужно удалить если мы удаляем соотв. автора
  private List<Comment> comments;
внесем изменеия в сущность коммент , автор был строчкой а теперь сделаем эту переменную класса автор
нужно вместо Column написать ДЖОИН Column с именем авторИД и указать тиа связи:
**   @ManyToOne
  @JoinColumn(name = "author_id") она не может иметь значение НАЛЛ
  //  private String author;
  private Author author; коментарии м.б. привязаны только к 1-му автору
  JoinColumn указывает что поле author_id будет внешним ключом
Теперь есть двусторонняя связь (У КАЖДОГО АВТОРА М.Б. МНОГО КОМЕНТАРИЕВ, А У КОМЕНТАРИЯ ТОЛЬКО 1 АВТОР)
- ДЛЯ РАБОТЫ С АВТОРОМ НАМ ПОНАДОБИТСЯ АТОР ДТО (ОБЪЕКТ ДЛЯ ПЕРЕДАЧИ ДАННЫХ)
пометим класс @Data чтобы автоматически добавлять ГЕТТЕРЫ и СЕТТЕРЫ
- создадим для сущности автор соответствующий РЕПОЗИТОРИЙ (создаем интерфейс автор и наследуем его от JPA репозитория)
- создадим СЕРВИС для авторов , имплементируем методы, подключаем репозиторий
чтобы заработало нужно добавть аннотацию СЕРВИС
  @Service
  @RequiredArgsConstructor
  public class AuthorCRUDService implements CRUDService {
}
добавим @Slf4j он поможет
- реализуем методы
  //т.к. мы будем по ИД получать АТОРА то нам нужно указать не обжект а автор
  // и нам нужно создать статические методы маппинга
  public static Author mapToEntity(AuthorDto authorDto) {
  //создаем автора:
  Author author = new Author();
  author.setId(authorDto.getId());
  author.setFirstName(authorDto.getFirstName());
  author.setLastName(authorDto.getLastName());
  author.setRating(authorDto.getRating());
  author.setComments(authorDto.getComments()
  .stream()
  .map(CommentCRUDService::mapToEntity)
  .toList()); //получаем список коментариев, а нам нужен список объектов класса коммент ДТО, нужно преобразовать с помощью стрима
  return author;
  }
  public static AuthorDto mapToDto(Author author) {
  AuthorDto authorDto = new AuthorDto();
  authorDto.setId(author.getId());
  authorDto.setFirstName(author.getFirstName());
  authorDto.setLastName(author.getLastName());
  authorDto.setRating(author.getRating());
  authorDto.setComments(author.getComments()
  .stream()
  .map(CommentCRUDService::mapToDto)
  .toList()); //получаем список коментариев, а нам нужен список объектов класса коммент ДТО, нужно преобразовать с помощью стрима
  return authorDto;
  }
- теперь нужно получить автора по его идентификатору :
- настроили методы
** Вылезла проблема вКомментКРУДсервисе
Нужно чтобы в КОММЕНТДТО была переменная авторДТО, и в КомментКРУДСервисе нужно преобразовать в маптодо
  commentDto.setAuthor(AuthorCRUDService.mapToDto(comment.getAuthor()));
и в     public static Comment mapToEntity(CommentDto commentDto) сделать обратное преобразование:
  comment.setAuthor(AuthorCRUDService.mapToEntity(commentDto.getAuthor()));

-Нужно создать контроллер: АВТОРКОНТРОЛЛЕР


- Виды стратегии

Lazy (ленивая загрузка): здесь данные загружаются только
по мере необходимости, что позволяет уменьшить нагрузку
на базу данных, но требует более аккуратного управления
сессиями и транзакциями. 

Eager (жадная загрузка): при этом типе загрузки все
связанные данные подгружаются сразу, что может привести
к избыточной нагрузке на базу данных и замедлению
производительности приложения.

Аннотация
@Transactional
Атомарность
Согласованность
Изоляция
Управление границами транзакций
ACID